好的，将多个微服务合并为一个单体服务是一个重要的架构调整。为了确保平稳过渡并降低风险，我建议采用分阶段的策略。

  这是一个规划实施方案：


  第一阶段：分析与设计 (1-2天)


   1. 代码结构分析:
       * 全面分析 common, app, facade, 以及 service/ 目录下的所有服务的代码，理解每个服务的功能、API接口、依赖关系和数据模型。
       * 重点关注 go.mod 文件，梳理出项目的模块依赖关系。
       * 分析 app 服务，它作为 GraphQL 网关，是所有服务的入口，是合并的核心。


   2. 配置与部署分析:
       * 研究 config/ 目录下的配置文件，了解各服务的配置方式。
       * 分析 Jenkinsfile 和 package.sh 等脚本，理解当前的构建和部署流程。


   3. 设计合并方案:
       * 目标: 将所有业务逻辑合并到 app 服务中，使其成为唯一的单体服务。
       * 代码迁移: 将 facade 和 service/* 中的代码，作为 app 服务的内部包（package）进行迁移。
       * 配置统一: 将所有服务的配置项统一到 app 服务的配置文件中。
       * 单一部署: 最终只需要编译和部署 app 服务。


  第二阶段：实施 (3-5天)


   1. 创建主干分支:
       * 在 Git 中创建一个新的长期分支（例如 feature/merge-to-monolith），所有合并工作都在这个分支上进行，不影响主分支的开发。


   2. 依赖整合:
       * 将 facade 和各个 service 的 go.mod 中的依赖项，合并到 app/go.mod 文件中。可以借助 go get 或手动编辑完成，然后运行 go mod tidy 来清理。


   3. 代码迁移 (核心步骤):
       * 迁移 `facade`: 将 facade 目录下的所有代码，移动到 /facade 目录下。然后，修改 app 服务中所有引用到 facade 的 import 路径。
       * 迁移 `service`: 在 app 目录下创建一个新的 services 目录。将 service/basic/ 和 service/platform/ 下的所有服务代码，分别迁移到
         app/services/basic/ 和 app/services/platform/。
       * 更新 import 路径: 这是最繁重的工作。需要全局搜索并替换旧的 import 路径为新的路径。例如，polaris-backend/facade/projectfacade 需要被替换为
         polaris-backend/facade/projectfacade。


   4. 移除冗余代码:
       * 迁移完成后，删除顶层的 facade 和 service 目录。
       * 删除被迁移服务的 go.mod, go.sum 以及独立的 main.go (如果存在)。


  第三阶段：测试与验证 (2-3天)


   1. 编译测试:
       * 在 app 目录下，运行 go build，解决所有编译错误。这通常是由于 import 路径问题或依赖冲突引起的。


   2. 单元测试:
       * 运行 app 服务下的所有单元测试 (go test ./...)，确保核心业务逻辑的正确性。


   3. 集成测试:
       * 在本地环境中，启动合并后的单体 app 服务。
       * 使用 API 测试工具 (如 Postman) 或已有的集成测试用例，对所有关键API进行回归测试，确保功能与合并前一致。


   4. 清理构建脚本:
       * 修改 package.sh, Jenkinsfile 等，移除对旧服务的构建和部署逻辑，只保留对 app 服务的操作。

  第四阶段：上线与监控


   1. 灰度发布 (如果条件允许):
       * 先将单体服务部署到预发布或灰度环境，进行小范围的真实流量测试。


   2. 正式上线:
       * 在业务低峰期进行上线部署。


   3. 监控:
       * 上线后，密切关注服务的日志、性能指标（CPU, 内存）和业务指标，确保服务稳定运行。


  风险与应对:


   * 风险: import 路径修改工作量大，容易遗漏。
   * 应对: 使用 IDE 的全局搜索替换功能，并依赖编译器来发现错误。


   * 风险: 依赖冲突。
   * 应对: 仔细处理 app/go.mod，必要时升级或降级部分依赖库的版本。


   * 风险: 功能回归。
   * 应对: 充分的集成测试是关键。


  这个方案将一个复杂的大任务分解成了多个可管理的小步骤。您希望我从哪一步开始协助您执行？